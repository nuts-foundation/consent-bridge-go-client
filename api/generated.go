// Package api provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"net/http"
	"strings"
	"time"
)

// ASymmetricKey defines component schema for ASymmetricKey.
type ASymmetricKey struct {
	Alg         *string    `json:"alg,omitempty"`
	CipherText  *string    `json:"cipherText,omitempty"`
	LegalEntity Identifier `json:"legalEntity"`
}

// ConsentId defines component schema for ConsentId.
type ConsentId struct {
	UUID       *string `json:"UUID,omitempty"`
	ExternalId *string `json:"externalId,omitempty"`
}

// ConsentRecord defines component schema for ConsentRecord.
type ConsentRecord struct {
	AttachmentHash *string                    `json:"attachmentHash,omitempty"`
	CipherText     *string                    `json:"cipherText,omitempty"`
	Metadata       *Metadata                  `json:"metadata,omitempty"`
	Signatures     []PartyAttachmentSignature `json:"signatures,omitempty"`
}

// Domain defines component schema for Domain.
type Domain string

// FullConsentRequestState defines component schema for FullConsentRequestState.
type FullConsentRequestState struct {
	ConsentId      ConsentId       `json:"consentId"`
	ConsentRecords []ConsentRecord `json:"consentRecords,omitempty"`
	LegalEntities  []Identifier    `json:"legalEntities"`
}

// Identifier defines component schema for Identifier.
type Identifier string

// Metadata defines component schema for Metadata.
type Metadata struct {
	Domain                 []Domain        `json:"domain"`
	OrganisationSecureKeys []ASymmetricKey `json:"organisationSecureKeys"`
	Period                 Period          `json:"period"`
	SecureKey              SymmetricKey    `json:"secureKey"`
}

// PartyAttachmentSignature defines component schema for PartyAttachmentSignature.
type PartyAttachmentSignature struct {
	Attachment  string           `json:"attachment"`
	LegalEntity Identifier       `json:"legalEntity"`
	Signature   SignatureWithKey `json:"signature"`
}

// Period defines component schema for Period.
type Period struct {
	ValidFrom time.Time  `json:"validFrom"`
	ValidTo   *time.Time `json:"validTo,omitempty"`
}

// SignatureWithKey defines component schema for SignatureWithKey.
type SignatureWithKey struct {
	Data      string `json:"data"`
	PublicKey string `json:"publicKey"`
}

// StateMachineId defines component schema for StateMachineId.
type StateMachineId string

// SymmetricKey defines component schema for SymmetricKey.
type SymmetricKey struct {
	Alg string `json:"alg"`
	Iv  string `json:"iv"`
}

// Client which conforms to the OpenAPI3 specification for this service. The
// server should be fully qualified with shema and server, ie,
// https://deepmap.com.
type Client struct {
	Server string
	Client http.Client
}

// GetAttachmentBySecureHash request
func (c *Client) GetAttachmentBySecureHash(ctx context.Context, secureHash string) (*http.Response, error) {
	req, err := NewGetAttachmentBySecureHashRequest(c.Server, secureHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// GetConsentRequestStateById request
func (c *Client) GetConsentRequestStateById(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetConsentRequestStateByIdRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewGetAttachmentBySecureHashRequest generates requests for GetAttachmentBySecureHash
func NewGetAttachmentBySecureHashRequest(server string, secureHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "secureHash", secureHash)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/attachment/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsentRequestStateByIdRequest generates requests for GetConsentRequestStateById
func NewGetConsentRequestStateByIdRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/consent_request_state/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD///F4tK7pEAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

