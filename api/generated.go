// Package api provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"net/http"
	"strings"
	"time"
)

// ASymmetricKey defines component schema for ASymmetricKey.
type ASymmetricKey struct {
	Alg         *string    `json:"alg,omitempty"`
	CipherText  *string    `json:"cipherText,omitempty"`
	LegalEntity Identifier `json:"legalEntity"`
}

// ConsentId defines component schema for ConsentId.
type ConsentId struct {
	UUID       *string `json:"UUID,omitempty"`
	ExternalId *string `json:"externalId,omitempty"`
}

// Domain defines component schema for Domain.
type Domain string

// FullConsentRequestState defines component schema for FullConsentRequestState.
type FullConsentRequestState struct {
	AttachmentHashes []string                   `json:"attachmentHashes,omitempty"`
	CipherText       *string                    `json:"cipherText,omitempty"`
	ConsentId        ConsentId                  `json:"consentId"`
	LegalEntities    []Identifier               `json:"legalEntities"`
	Metadata         *Metadata                  `json:"metadata,omitempty"`
	Signatures       []PartyAttachmentSignature `json:"signatures,omitempty"`
}

// Identifier defines component schema for Identifier.
type Identifier string

// Metadata defines component schema for Metadata.
type Metadata struct {
	Domain                 []Domain        `json:"domain"`
	OrganisationSecureKeys []ASymmetricKey `json:"organisationSecureKeys"`
	Period                 Period          `json:"period"`
	SecureKey              SymmetricKey    `json:"secureKey"`
}

// PartyAttachmentSignature defines component schema for PartyAttachmentSignature.
type PartyAttachmentSignature struct {
	Attachment  string           `json:"attachment"`
	LegalEntity Identifier       `json:"legalEntity"`
	Signature   SignatureWithKey `json:"signature"`
}

// Period defines component schema for Period.
type Period struct {
	ValidFrom time.Time  `json:"validFrom"`
	ValidTo   *time.Time `json:"validTo,omitempty"`
}

// SignatureWithKey defines component schema for SignatureWithKey.
type SignatureWithKey struct {
	Data      string `json:"data"`
	PublicKey string `json:"publicKey"`
}

// StateMachineId defines component schema for StateMachineId.
type StateMachineId string

// SymmetricKey defines component schema for SymmetricKey.
type SymmetricKey struct {
	Alg string `json:"alg"`
	Iv  string `json:"iv"`
}

// Client which conforms to the OpenAPI3 specification for this service. The
// server should be fully qualified with shema and server, ie,
// https://deepmap.com.
type Client struct {
	Server string
	Client http.Client
}

// GetAttachmentBySecureHash request
func (c *Client) GetAttachmentBySecureHash(ctx context.Context, secureHash string) (*http.Response, error) {
	req, err := NewGetAttachmentBySecureHashRequest(c.Server, secureHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// GetConsentRequestStateById request
func (c *Client) GetConsentRequestStateById(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetConsentRequestStateByIdRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewGetAttachmentBySecureHashRequest generates requests for GetAttachmentBySecureHash
func NewGetAttachmentBySecureHashRequest(server string, secureHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "secureHash", secureHash)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/attachment/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsentRequestStateByIdRequest generates requests for GetConsentRequestStateById
func NewGetConsentRequestStateByIdRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/consent_request_state/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

